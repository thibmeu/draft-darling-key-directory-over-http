



???                                                           F. Darling
Internet-Draft                                                T. Meunier
Intended status: Informational                                 S. Newton
Expires: 10 August 2025                                  Cloudflare Inc.
                                                         6 February 2025


                        Key Directory over HTTP
              draft-darling-key-directory-over-http-latest

Abstract

   This document defines recommendations for protocol implementers that
   wish to expose public keys over HTTP.  This allows new protocols to
   share public keys via HTTP with considerations for caching, rotation,
   or providing a well-known URL.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://thibmeu.github.io/draft-darling-key-directory-over-http/
   draft-darling-key-directory-over-http.html.  Status information for
   this document may be found at https://datatracker.ietf.org/doc/draft-
   darling-key-directory-over-http/.

   Discussion of this document takes place on the ???  mailing list
   (mailto:httpapi@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/httpapi/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/httpapi/.

   Source for this draft and an issue tracker can be found at
   https://github.com/thibmeu/draft-darling-key-directory-over-http.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 10 August 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Motivation
   3.  Presentation Language
     3.1.  Variable-Size Vector Length Headers
   4.  Conventions and Definitions
   5.  Architecture
     5.1.  Cache behaviour
     5.2.  Key ID
     5.3.  Rotation (kid, cache, others)
       5.3.1.  Algorithm
       5.3.2.  Scheduled (server, client behaviour)
       5.3.3.  Immediate (server, client behaviour)
     5.4.  Well known URL
     5.5.  Future considerations
       5.5.1.  Consistency
       5.5.2.  Key Transparency
   6.  Deployment Considerations
   7.  Privacy Considerations
   8.  Security Considerations
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Test vectors
   Appendix B.  Use cases
     B.1.  DAP
     B.2.  OHTTP
     B.3.  Privacy Pass
     B.4.  Masque relay
   Acknowledgments
   Authors' Addresses

1.  Introduction

   Multiple Internet protocols rely on public key cryptography.  They
   require keys to be distributed by origins to clients.  This can be
   done via certificates, software releases, or HTTP.  This document
   focuses on this last mechanism.  It aims to set recommendations on
   how to design a key directory that should be served over HTTP.

   Distribution via HTTP allows for a more dynamic use of public keys,
   for rotation, or caching on intermediate servers or clients.  This
   document specifies how clients and mirrors should consume cache
   directive set by origins, how origins should expose their key
   directory, and rotate them.  The document does not cover a specific
   directory format, as these needs might vary from one protocol to the
   next.

2.  Motivation

   JOSE and COSE both define ways to structure key sets, but no way to
   serve them.  This creates issues when serving these keys over HTTP
   because caching is not taken into account, and there is no standard
   way to derive an ID from a key.  Privacy Pass, OHTTP, and DAP also
   went down the road of defining their own directory, and were faced
   with similar issues.  While Privacy Pass seems to have been the most
   thorough, even started considering consistency, these all seem to be
   duplicated efforts that would benefit from being consolidated into
   one specification.

3.  Presentation Language

   This document uses the TLS presentation language [RFC8446] to
   describe the structure of protocol messages.  In addition to the base
   syntax, it uses two additional features: the ability for fields to be
   optional and the ability for vectors to have variable-size length
   headers.

3.1.  Variable-Size Vector Length Headers

   In the TLS presentation language, vectors are encoded as a sequence
   of encoded elements prefixed with a length.  The length field has a
   fixed size set by specifying the minimum and maximum lengths of the
   encoded sequence of elements.

   In this document, there are several vectors whose sizes vary over
   significant ranges.  So instead of using a fixed-size length field,
   it uses a variable-size length using a variable-length integer
   encoding based on the one described in Section 16 of [RFC9000].  They
   differ only in that the one here requires a minimum-size encoding.
   Instead of presenting min and max values, the vector description
   simply includes a V.  For example:

   struct {
       uint32 fixed<0..255>;
       opaque variable<V>;
   } StructWithVectors;

4.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The following terms are used throughout this document:

   Client:  An entity using public key material

   Origin:  An entity exposing public key material via HTTP

   Mirror:  An intermediary entity between client and server.  May cache
      data, and act as a privacy proxy

   Key metadata:  Public data associated to a public key

   Key Directory:  Set of public keys

   Directory Metadata:  Public data associated to a key directory.  This
      is protocol specific.

5.  Architecture

   A server is exposing a key directory for clients to fetch.  Clients
   MAY fetch the directory from a Mirror, either to protect its privacy,
   or because the Server wants to leverage a content delivery network.

   This document focuses on the below interaction, which is triggered
   when the Client does not have valid key for the server.  This can be
   because the Client is new, its cache is expired, or the server
   refuses requests with the current key set.

   +--------+                +--------+               +--------+
   | Client |                | Mirror |               | Origin |
   +---+----+                +---+----+               +----+---+
       |                         |                         |
       +--- GET Key Directory -->|                         |
       |                         +--- GET Key Directory -->|
       |                         |<---- Key Directory -----+
       |                         +---.                     |
       |                         |    | cache              |
       |                         |<--'                     |
       |<---- Key Directory -----+                         |
       +---.                     |                         |
       |    | cache              |                         +---.
       |<--'                     |                         |    | rotate
       |                         |                         |<--'
       |                         |                         |

5.1.  Cache behaviour

   Cache control, intermediaries

   Client should use cache directive per key, so that if a key becomes
   invalid, they use the next one in their cache.

   TODO: write about key preference, based on not-before, not-after, or
   order in the directory.

5.2.  Key ID

   Each key in the directory MUST be associated with a unique Key ID.

   Key ID is derived from key material that can be shared publicly.
   Protocol implementers SHOULD provide the following blob of data.

   struct {
     opaque ProtocolBlob<V>;
   } PublicKeyMaterial;

   PublicKeyMaterial can be composed of both cryptographic material and
   metadata.

   Key ID is defined has follow

   key_id = encode(H(PublicKeyMaterial))

   where

   *  PublicKeyMaterial is a length-prefix-encoded blob of data

   *  H is a hash function

   *  encode is some encoding function

   The Truncated Key ID is derived from the Key ID and uniquely
   identifies a Key within a Key Directory.  For example, Privacy Pass
   uses the last byte of the the Key ID in network byte order.  Other
   protocols use other schemes.

   Open question about H: * Should the draft provide specific H * Should
   the draft define an IANA registry and require protocols to register
   their H

5.3.  Rotation (kid, cache, others)

5.3.1.  Algorithm

   We approach a public key generation by the function Generate(params,
   RAND) -> (publickey, privatekey, metadata)

   At any point in time, all keys in the directory MUST have a unique
   truncated key id.  When adding a key in the directory, that key MUST
   have a unique truncated key id.

   Generation looks as follows

   do
     (publickey, privatekey, metadata) <- Generate(params, RAND)
     public_key_material = (publickey | metadata)
     key_id <- H(public_key_material)
   while (key_id is not unique)

5.3.2.  Scheduled (server, client behaviour)

   Two options:

   *  passive = rely on cache header to set not-after on the client
      side. stop advertising the key at time t, and delete it at time
      t+maxage take intermediate into consideration

   *  active = keep serving the key but add not-after before expiration.
      It should be NOW()+maxage

   In both case, the protocol MUST define an error to signal a key which
   is not supported.  It is RECOMMENDED to use truncated token ID as a
   short identifier.

5.3.3.  Immediate (server, client behaviour)

   There are moment where keys have to be rotated immediately.  Existing
   keys may have to be invalidated and/or new keys be provisioned.
   Immediate key rotation may happen in the event of a key compromise,
   loss, or other imperious reason.

   Immediate key rotation will cause some client requests to the server
   to fail until the client retrieves a new version of the directory.
   The key directory endpoint is going to be placed under a higher load.

   Client requests are expected to fail.

   1.  You MAY introduce a random backoff to spread the load of key
       distribution over time.  See #TODO link to caching section

   2.  Clients on a scheduled rotation MAY be configured to distrust
       rotation outside a fixed schedule.  Protocols SHOULD define such
       policies.

5.4.  Well known URL

   It is RECOMMENDED protocol register a [WELL-KNOWN]URL and associated
   content-type.

   A key directory server MUST support both GET and HEAD request on that
   endpoint.

   GET /.well-known/<your-protocol>

   HTTP/1.1 200 OK
   Cache-Control: max-age=300
   Content-Type: <your-protocol>

   HEAD requests can be used by clients to cheaply determine if the
   directory has changed.

5.5.  Future considerations

   These considerations should be addressed in future drafts.

5.5.1.  Consistency

   Consistency allows client to prevent themselves from split view
   attack.  A proposal that has been made for Privacy Pass is to use
   multiple mirrors [CONSISTENCY].  With a sufficiently high quorum,
   clients get more confident that they are not singled out.  It
   presents scalability issues as you need multiple mirrors, and have
   one more requests from client per mirror in the quorum.

5.5.2.  Key Transparency

   Key Directory over HTTP should integrate with transparency, once the
   protocol has been defined in [KEYTRANS].  There are specific
   consideration as to what goes in the log: the full directory, keys
   individually, privacy considerations.

6.  Deployment Considerations

   Rotation schedule: fast?  Proxy improves client experience and
   shields key directory server

7.  Privacy Considerations

   TODO Privacy

   Clients fetching keys mean they reveal their IP, time, and other
   informations.  When the key directory is for an external service,
   Clients SHOULD consider proxying their traffic through a mirror
   server.  Mirrors SHOULD NOT collide with the key server.

8.  Security Considerations

   TODO Security

9.  IANA Considerations

   This document has no IANA actions.

10.  References

10.1.  Normative References

   [CONSISTENCY]
              Beurdouche, B., Finkel, M., Valdez, S., Wood, C. A., and
              T. Pauly, "Checking Resource Consistency with HTTP
              Mirrors", Work in Progress, Internet-Draft, draft-ietf-
              privacypass-consistency-mirror-00, 30 January 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-
              privacypass-consistency-mirror-00>.

   [KEYTRANS] McMillion, B. and F. Linker, "Key Transparency Protocol",
              Work in Progress, Internet-Draft, draft-ietf-keytrans-
              protocol-00, 10 December 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-
              keytrans-protocol-00>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/rfc/rfc8446>.

   [WELL-KNOWN]
              Nottingham, M., "Well-Known Uniform Resource Identifiers
              (URIs)", RFC 8615, DOI 10.17487/RFC8615, May 2019,
              <https://www.rfc-editor.org/rfc/rfc8615>.

10.2.  Informative References

   [RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/rfc/rfc9000>.

Appendix A.  Test vectors

   List how to test cache List how to test rotation

Appendix B.  Use cases

   See existing key directory on https://key-directory-over-
   http.research.cloudflare.com/

B.1.  DAP

   HpkeConfigList [1]

   HpkeConfig HpkeConfigList<0..2^16-1>;

   struct {
     HpkeConfigId id;
     HpkeKemId kem_id;
     HpkeKdfId kdf_id;
     HpkeAeadId aead_id;
     HpkePublicKey public_key;
   } HpkeConfig;

   opaque HpkePublicKey<0..2^16-1>;
   uint16 HpkeAeadId; /* Defined in [HPKE] */
   uint16 HpkeKemId;  /* Defined in [HPKE] */
   uint16 HpkeKdfId;  /* Defined in [HPKE] */

   Partially informed comments:

   *  HpkeConfigId could be removed

   *  Need not-before to handle early capture

   [1] https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-
   13#section-4.5.1

B.2.  OHTTP

   Key Configutation [1]

   HPKE Symmetric Algorithms {
     HPKE KDF ID (16),
     HPKE AEAD ID (16),
   }

   Key Config {
     Key Identifier (8),
     HPKE KEM ID (16),
     HPKE Public Key (Npk * 8),
     HPKE Symmetric Algorithms Length (16) = 4..65532,
     HPKE Symmetric Algorithms (32) ...,
   }

   Partially informed comments:

   *  Key Identifier could be removed/be deterministic

   *  No mention of not-before

   *  No mention of HTTP Caching for rotation

   [1] https://www.ietf.org/rfc/rfc9458.html#name-key-configuration

B.3.  Privacy Pass

   Issuer directory [1]

    {
       "issuer-request-uri": "https://issuer.example.net/request",
       "token-keys": [
         {
           "token-type": 2,
           "token-key": "MI...AB",
           "not-before": 1686913811,
         },
         {
           "token-type": 2,
           "token-key": "MI...AQ",
         }
       ]
    }

   Partially informed comments: * Not as flexible as HPKE * Has some
   protocol metadata (token-type, issuer-request-uri, rate-limit)

   [1] https://www.rfc-editor.org/rfc/rfc9578#name-configuration

B.4.  Masque relay

   ..

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Fisher Darling
   Cloudflare Inc.
   Email: fisher@darling.dev


   Thibault Meunier
   Cloudflare Inc.
   Email: ot-ietf@thibault.uk


   Simon Newton
   Cloudflare Inc.
   Email: rfc@simonnewton.com
