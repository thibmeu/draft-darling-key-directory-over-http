



???                                                           F. Darling
Internet-Draft                                                T. Meunier
Intended status: Informational                                 S. Newton
Expires: 4 August 2025                                   Cloudflare Inc.
                                                         31 January 2025


                        Key Directory over HTTP
              draft-darling-key-directory-over-http-latest

Abstract

   Service owners have a use to share public key as part of a standard
   directory.  This is meant to be convenient to share, allow for
   rotation, and be secure to man-in-the-middle or split-view attack.
   This document defines recommendations for protocol implementers.

   Notes: JWK does not offer a standard endpoint either with jose or
   cose.  It has a draft for HPKE [1]/[2].  There is an endpoint /.well-
   known/jwks.json that is tribal knowledge but is not registered with
   IANA.  Certificates could also be a similar mechanism, but there is
   x509 as well.  This directory might be bootstraped with x509 backed
   trust, but this is an overhead we don't touch.  I'm not confident in
   defining a jwk subset (all attributes [3]).

   [1] https://datatracker.ietf.org/doc/draft-ietf-jose-hpke-encrypt/
   [2] https://datatracker.ietf.org/doc/draft-ietf-cose-hpke/ [3]
   https://www.iana.org/assignments/jose/jose.xhtml

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://thibmeu.github.io/draft-darling-key-directory-over-http/
   draft-darling-key-directory-over-http.html.  Status information for
   this document may be found at https://datatracker.ietf.org/doc/draft-
   darling-key-directory-over-http/.

   Discussion of this document takes place on the ???  mailing list
   (mailto:httpapi@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/httpapi/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/httpapi/.

   Source for this draft and an issue tracker can be found at
   https://github.com/thibmeu/draft-darling-key-directory-over-http.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 4 August 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Architecture
     3.1.  Cache behaviour
     3.2.  Key id
     3.3.  Rotation (kid, cache, others)
       3.3.1.  Algorithm
       3.3.2.  Scheduled (server, client behaviour)
       3.3.3.  Immediate (server, client behaviour)
     3.4.  Well known URL
     3.5.  Future considerations
       3.5.1.  Consistency
       3.5.2.  Key Transparency
   4.  Deployment Considerations
   5.  Privacy Considerations
   6.  Security Considerations
   7.  IANA Considerations
   8.  Normative References
   Appendix A.  Test vectors
   Appendix B.  Use cases
     B.1.  DAP
     B.2.  OHTTP
     B.3.  Privacy Pass
     B.4.  Masque relay
   Acknowledgments
   Authors' Addresses

1.  Introduction

   Multiple Internet protocols rely on public key cryptography.  They
   require keys to be distributed by servers to clients.  This could be
   done via certificates, via software releases, or via HTTP.  This
   document focuses on this last mechanism.  It aims to set
   recommendation on how to design a key directory that should be served
   over HTTP.

   Distribution via HTTP allows for a more dynamic use of public keys,
   for rotation, or caching on intermediate servers or clients.

   The document covers:

   1.  cache behaviour

   2.  how to populate key id

   3.  possibly well known url and client behaviour

   4.  rotation considerations (kid, cache, others), to minimize key
       compromise

   Format is a lot more work (likely different as well), so reusing COSE
   key set and jwk set could work for examples (maybe more, not sure)

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The following terms are used throughout this document:

   Client:  An entity using public key material

   Origin:  An entity exposing public key material via HTTP

   Mirror:  An intermediary entity between client and server.  May cache
      data, and act as a privacy proxy

   Key metadata:  Public data associated to a public key

   Key Directory:  Set of public keys

   Directory Metadata:  Public data associated to a key directory.  This
      is protocol specific.

3.  Architecture

   A server is exposing a key directory for clients to fetch.  Clients
   MAY fetch the directory from a Mirror, either to protect its privacy,
   or because the Server wants to leverage a content delivery network.

   This document focuses on the below interaction, which is triggered
   when the Client does not have valid key for the server.  This can be
   because the Client is new, its cache is expired, or the server
   refuses requests with the current key set.

   +--------+                +--------+               +--------+
   | Client |                | Mirror |               | Origin |
   +---+----+                +---+----+               +----+---+
       |                         |                         |
       +--- GET Key Directory -->|                         |
       |                         +--- GET Key Directory -->|
       |                         |<---- Key Directory -----+
       |                         +---.                     |
       |                         |    | cache              |
       |                         |<--'                     |
       |<---- Key Directory -----+                         |
       +---.                     |                         |
       |    | cache              |                         +---.
       |<--'                     |                         |    | rotate
       |                         |                         |<--'
       |                         |                         |

3.1.  Cache behaviour

   Cache control, intermediaries

   Client should use cache directive per key, so that if a key becomes
   invalid, they use the next one in their cache.

   TODO: write about key preference, based on not-before, not-after, or
   order in the directory.

3.2.  Key id

   Protocol implementers pass a blob of data based on public key
   material/others Key ID = Hash(blob)

   Key ID have an associated truncated Key ID.  The size of truncated
   Key ID depends on the number of keys a directory expects to serve at
   one point in time

              +===================+========================+
              | Keys in directory | Truncated key ID bytes |
              +===================+========================+
              | 1-255             | 1                      |
              +-------------------+------------------------+
              | 256-65535         | 2                      |
              +-------------------+------------------------+
              | 65535-*           | Not supported          |
              +-------------------+------------------------+

                                 Table 1

   Truncated key ID = last bytes of key ID in network byte order.

3.3.  Rotation (kid, cache, others)

3.3.1.  Algorithm

   We approach a public key generation by the function Generate(params,
   RAND) -> (publickey, privatekey, metadata)

   At any point in time, keys in the directory MUST have a unique
   truncated key id.  When adding a key in the directory, that key MUST
   have a unique truncated key id.

   Generation looks as follow

   do
     (publickey, privatekey, metadata) <- Generate(params, RAND)
     keyid <- H(publickey|metadata)
     truncated_key_id <- last_bytes(keyid)
   while (truncated_key_id is not unique)

3.3.2.  Scheduled (server, client behaviour)

   Two options:

   *  passive = rely on cache header to set not-after on the client
      side. stop advertising the key at time t, and delete it at time
      t+maxage take intermediate into consideration

   *  active = keep serving the key but add not-after before expiration.
      It should be NOW()+maxage

   In both case, the protocol MUST define an error to signal a key which
   is not supported.  It is RECOMMENDED to use truncated token ID as a
   short identifier.

3.3.3.  Immediate (server, client behaviour)

   There are moment where keys have to be rotated immediatly.  Existing
   keys may have to be invalidated and/or new keys be provisioned.
   Immediate keys rotation may happen in the event of a key compromise,
   loss, or other imperious reason.

   Immediate key rotation will cause some client request to the server
   to fail until they retrieve a new version of the directory.  The key
   directory endpoint is going to be placed under a higher load.

   Client requests are expected to fail.

   1.  You MAY introduce a random backoff to spread the load of key
       distribution over time

   2.  Clients on a scheduled rotation MAY be configured to distrust
       rotation outside a fixed schedule.  Protocols SHOULD define such
       policies.

3.4.  Well known URL

   It is RECOMMENDED protocol register a [WELL-KNOWN]URL and associated
   content-type.

   A key directory server MUST support both GET and HEAD request on that
   endpoint.

   GET /.well-known/<your-protocol>

   HTTP/1.1 200 OK
   Cache-Control: max-age=300
   Content-Type: <your-protocol>

3.5.  Future considerations

   These considerations should be addressed in future drafts.

3.5.1.  Consistency

   Consistency allows client to prevent themselves from split view
   attack.  A proposal that has been made for Privacy Pass is to use
   multiple mirrors [CONSISTENCY].  With a sufficiently high quorum,
   clients get more confident that they are not singled out.  It
   presents scalability issues as you need multiple mirrors, and have
   one more requests from client per mirror in the quorum.

3.5.2.  Key Transparency

   Key Directory over HTTP should integrate with transparency, once the
   protocol has been defined in [KEYTRANS].  There are specific
   consideration as to what goes in the log: the full directory, keys
   individually, privacy considerations.

4.  Deployment Considerations

   Rotation schedule: fast?  Proxy improves client experience and
   shields key directory server

5.  Privacy Considerations

   TODO Privacy

   Clients fetching keys mean they reveal their IP, time, and other
   informations.  When the key directory is for an external service,
   Clients SHOULD consider proxying their traffic through a mirror
   server.  Mirrors SHOULD NOT collide with the key server.

6.  Security Considerations

   TODO Security

7.  IANA Considerations

   This document has no IANA actions.

8.  Normative References

   [CONSISTENCY]
              Beurdouche, B., Finkel, M., Valdez, S., Wood, C. A., and
              T. Pauly, "Checking Resource Consistency with HTTP
              Mirrors", Work in Progress, Internet-Draft, draft-ietf-
              privacypass-consistency-mirror-00, 30 January 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-
              privacypass-consistency-mirror-00>.

   [KEYTRANS] McMillion, B. and F. Linker, "Key Transparency Protocol",
              Work in Progress, Internet-Draft, draft-ietf-keytrans-
              protocol-00, 10 December 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-
              keytrans-protocol-00>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [WELL-KNOWN]
              Nottingham, M., "Well-Known Uniform Resource Identifiers
              (URIs)", RFC 8615, DOI 10.17487/RFC8615, May 2019,
              <https://www.rfc-editor.org/rfc/rfc8615>.

Appendix A.  Test vectors

   List how to test cache List how to test rotation

Appendix B.  Use cases

   See existing key directory on https://key-directory-over-
   http.research.cloudflare.com/

B.1.  DAP

   HpkeConfigList [1]

   HpkeConfig HpkeConfigList<0..2^16-1>;

   struct {
     HpkeConfigId id;
     HpkeKemId kem_id;
     HpkeKdfId kdf_id;
     HpkeAeadId aead_id;
     HpkePublicKey public_key;
   } HpkeConfig;

   opaque HpkePublicKey<0..2^16-1>;
   uint16 HpkeAeadId; /* Defined in [HPKE] */
   uint16 HpkeKemId;  /* Defined in [HPKE] */
   uint16 HpkeKdfId;  /* Defined in [HPKE] */

   Partially informed comments:

   *  HpkeConfigId could be removed

   *  Need not-before to handle early capture

   [1] https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-
   13#section-4.5.1

B.2.  OHTTP

   Key Configutation [1]

   HPKE Symmetric Algorithms {
     HPKE KDF ID (16),
     HPKE AEAD ID (16),
   }

   Key Config {
     Key Identifier (8),
     HPKE KEM ID (16),
     HPKE Public Key (Npk * 8),
     HPKE Symmetric Algorithms Length (16) = 4..65532,
     HPKE Symmetric Algorithms (32) ...,
   }

   Partially informed comments:

   *  Key Identifier could be removed/be deterministic

   *  No mention of not-before

   *  No mention of HTTP Caching for rotation

   [1] https://www.ietf.org/rfc/rfc9458.html#name-key-configuration

B.3.  Privacy Pass

   Issuer directory [1]

    {
       "issuer-request-uri": "https://issuer.example.net/request",
       "token-keys": [
         {
           "token-type": 2,
           "token-key": "MI...AB",
           "not-before": 1686913811,
         },
         {
           "token-type": 2,
           "token-key": "MI...AQ",
         }
       ]
    }

   Partially informed comments: * Not as flexible as HPKE * Has some
   protocol metadata (token-type, issuer-request-uri, rate-limit)

   [1] https://www.rfc-editor.org/rfc/rfc9578#name-configuration

B.4.  Masque relay

   ..

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Fisher Darling
   Cloudflare Inc.


   Thibault Meunier
   Cloudflare Inc.
   Email: ot-ietf@thibault.uk


   Simon Newton
   Cloudflare Inc.
   Email: rfc@simonnewton.com
