



???                                                           F. Darling
Internet-Draft                                                T. Meunier
Intended status: Informational                                 S. Newton
Expires: 14 August 2025                                  Cloudflare Inc.
                                                        10 February 2025


                        Key Directory over HTTP
              draft-darling-key-directory-over-http-latest

Abstract

   This document defines recommendations for protocols that expose
   public keys over HTTP.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://thibmeu.github.io/draft-darling-key-directory-over-http/
   draft-darling-key-directory-over-http.html.  Status information for
   this document may be found at https://datatracker.ietf.org/doc/draft-
   darling-key-directory-over-http/.

   Discussion of this document takes place on the ???  mailing list
   (mailto:httpapi@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/browse/httpapi/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/httpapi/.

   Source for this draft and an issue tracker can be found at
   https://github.com/thibmeu/draft-darling-key-directory-over-http.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 14 August 2025.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Motivation
   3.  Presentation Language
     3.1.  Variable-Size Vector Length Headers
   4.  Conventions and Definitions
   5.  Architecture
     5.1.  Key ID
     5.2.  Key Selection
       5.2.1.  Algorithm
     5.3.  Rotation
       5.3.1.  Algorithm
       5.3.2.  Scheduled rotation
       5.3.3.  Immediate
     5.4.  Cache behaviour
       5.4.1.  not-before fields
       5.4.2.  cache directives
       5.4.3.  Client cache refresh
     5.5.  Well known URL
     5.6.  Future considerations
       5.6.1.  Consistency
       5.6.2.  Key Transparency
   6.  Deployment Considerations
   7.  Privacy Considerations
   8.  Security Considerations
   9.  IANA Considerations
   10. References
     10.1.  Normative References
     10.2.  Informative References
   Appendix A.  Test vectors
   Appendix B.  Use cases
     B.1.  DAP
     B.2.  OHTTP
     B.3.  Privacy Pass
     B.4.  Masque relay
   Acknowledgments
   Authors' Addresses

1.  Introduction

   Multiple Internet protocols rely on public key cryptography.  They
   require keys to be distributed by origins to clients.  This can be
   done via certificates, software releases, or HTTP.  This document
   focuses on this last mechanism.  It aims to set recommendations on
   how to design a key directory that is served over HTTP.

   Distribution via HTTP allows for a more dynamic use of public keys,
   for rotation, or caching on intermediate mirrors or clients.  This
   document specifies which cache directives origin should set, how
   clients and mirrors should consume cache directive set by origins,
   how origins should expose their key directory, and rotate them.  The
   document does not cover a specific directory format, as these needs
   might vary from one protocol to the next.

2.  Motivation

   Section 5 of [JOSE] and Section 7 of [COSE] both define ways to
   structure key sets, but no way to serve them.  This creates issues
   when serving these keys over HTTP because caching is not taken into
   account, and there is no standard way to derive an ID from a key.
   Section 4 of [PRIVACYPASS], Section 3 of [OHTTP], and Section 4.7.1
   of [DAP] are also defining their own public key directory, and are
   faced with similar issues.  While Privacy Pass seems to have been the
   most thorough, even considering [CONSISTENCY] for instance, these
   seem to be duplicated efforts that would benefit from being
   consolidated into one specification.

3.  Presentation Language

   This document uses the TLS presentation language [RFC8446] to
   describe the structure of protocol messages.  In addition to the base
   syntax, it uses two additional features: the ability for fields to be
   optional and the ability for vectors to have variable-size length
   headers.

3.1.  Variable-Size Vector Length Headers

   In the TLS presentation language, vectors are encoded as a sequence
   of encoded elements prefixed with a length.  The length field has a
   fixed size set by specifying the minimum and maximum lengths of the
   encoded sequence of elements.

   In this document, there are several vectors whose sizes vary over
   significant ranges.  So instead of using a fixed-size length field,
   it uses a variable-size length using a variable-length integer
   encoding based on the one described in Section 16 of [RFC9000].  They
   differ only in that the one here requires a minimum-size encoding.
   Instead of presenting min and max values, the vector description
   simply includes a V.  For example:

   struct {
       uint32 fixed<0..255>;
       opaque variable<V>;
   } StructWithVectors;

4.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   The following terms are used throughout this document:

   *Client:*  An entity using public key material.

   *Origin:*  An entity exposing public key material via HTTP.

   *Mirror:*  An intermediary entity between client and origin.  May
      cache data, and act as a privacy proxy.

   *Key metadata:*  Public data associated to a public key.

   *Key Directory:*  Set of public keys.

   *Directory Metadata:*  Public data associated to a key directory.
      This is protocol specific.

5.  Architecture

   An Origin is exposing a key directory for Clients to fetch.  Clients
   MAY fetch the directory from a Mirror, either to protect its privacy,
   or because the Origin wants to leverage a content delivery network.
   The endpoint and request pattern MUST be the same as if the fetch was
   to an Origin.

   This document focuses on the below interaction, which is triggered
   when the Client does not have valid key for the Origin.  This can be
   because the Client is new, its cache is expired, or the Origin
   refuses requests with the current key set.

   +--------+                +--------+               +--------+
   | Client |                | Mirror |               | Origin |
   +---+----+                +---+----+               +----+---+
       |                         |                         |
       +--- GET Key Directory -->|                         |
       |                         +--- GET Key Directory -->|
       |                         |<---- Key Directory -----+
       |                         +---.                     |
       |                         |    | cache              |
       |                         |<--'                     |
       |<---- Key Directory -----+                         |
       +---.                     |                         |
       |    | cache              |                         +---.
       |<--'                     |                         |    | rotate
       |                         |                         |<--'
       |                         |                         |

5.1.  Key ID

   Each key in the directory MUST be associated with a unique Key ID.

   Key ID MUST be derived from key material that is shared publicly.
   Protocols SHOULD provide the following blob of data:

   struct {
     opaque ProtocolBlob<V>;
   } PublicKeyMaterial;

   PublicKeyMaterial MAY be composed of both cryptographic material and
   metadata.

   Key ID is defined has follow:

   key_id = encode(H(PublicKeyMaterial))

   where

   *  PublicKeyMaterial is a length-prefix-encoded blob of data

   *  H is a hash function

   *  encode is some encoding function

   *TODO Open questions about H*

   *  Should the draft provide specific H?

   *  Should the draft define an IANA registry and require protocols to
      register their H?

5.2.  Key Selection

   The following is a deterministic algorithm for determining which Key
   a Client SHOULD use to fulfill their cryptographic needs.  By using a
   deterministic algorithm, Origins can more easily predict the effects
   of a Key rotation and implement grace periods, soak times, etc.
   Protocols MAY place additional restrictions, or push these decision
   details to deployments.

5.2.1.  Algorithm

   1.  *Filter invalid keys*: Exclude keys that:

       *  Have a not-after field in the past.

       *  Have a not-before field in the future.

       *  Do not meet required cryptographic properties.

   2.  *Set missing activation times*: If a key does not have a not-
       before field, set it to either:

       *  The Last-Modified header from the request as defined in
          Section 8.8.2 of [HTTP], if available.

       *  The Date header from the request as defined in Section 6.6.1
          of [HTTP], if available.

       *  The clientâ€™s local time.

   3.  *Sort by activation time*: If a not-before field exists, sort the
       remaining keys in *descending* order based on not-before.

   4.  *Select the first key*: Choose the first key from the Key
       Directory, as ordered in the Key Directory format.

   Clients SHOULD implement the Key Selection Algorithm.  Origins SHOULD
   present the newest Keys first.

   For protocols which define a not-before field, the above algorithm
   minimizes the chance that the Client uses a key that has expired
   between fetching the directory from the origin and its usage as part
   of the protocol.

   For protocols without a not-before field, using the first key allows
   Origin to present their key directory so that the newest is always
   first, and the soon-to-be-removed key is last.  This minimizes the
   chance of a client using an expired key.

   Expired key MAY be presented for completion, only if the protocol
   defines a not-after field.

5.3.  Rotation

   Clients and Origins SHOULD NOT assume a key directory is fixed.
   Origins SHOULD rotate keys on a schedule.  Clients SHOULD fetch keys
   upon an immediate rotation for security reasons.  This section goes
   over how Origins SHOULD rotate their keys, and how that interacts
   with scheduled and immediate rotations.

5.3.1.  Algorithm

   We approach a public key generation by the following function

   Generate(params, RAND) -> (publickey, privatekey, metadata)

   At any point in time, all keys in the directory MUST have a unique
   key id as defined in Section 5.1.  When adding a key in the
   directory, that key MUST have a unique key id.

   Generation looks as follows

   do
     (publickey, privatekey, metadata) <- Generate(params, RAND)
     public_key_material <- (publickey | metadata)
     key_id <- encode(H(public_key_material))
   while (key_id is not unique)

5.3.2.  Scheduled rotation

   Scheduled rotation happens at a time known to Origins, Clients, and
   Mirrors.  This MAY be a regular interval (monthly, weekly, daily), or
   an ad-hoc schedule agreed between all parties.

   Scheduled rotations MUST be communicated in one of the two mode below

   Passive:  Origins rely on cache headers to inform Clients about key
      expiry.  They stop advertising the key at time t, and delete it at
      time t_expiry=t+maxage.  Origins MAY have to take intermediate
      mirrors into considerations, if they are aware these mirrors don't
      respect their cache headers.  Active:

      Origins keep serving the key and add a not-after field.  This
      field MUST be at least t+maxage.

   With both modes, an Origin SHOULD signal a key is not supported by
   sending a response with status code 400.  It is RECOMMENDED to use
   key ID as defined in Section 5.1.

5.3.3.  Immediate

   Origins MIGHT have to rotate keys immediately.  Existing keys MAY
   have to be invalidated and/or new keys be provisioned.  Immediate key
   rotation can happen in the event of a key compromise, loss, or other
   imperious reason.

   Immediate key rotation will cause some client requests to the server
   to fail until the client and mirrors retrieve a new version of the
   directory.  The key directory endpoint is going to be placed under a
   higher load.

   1.  Origins MAY introduce a random backoff to spread the load of key
       distribution over time.  See Section 5.4

   2.  Clients on a scheduled rotation MAY be configured to distrust
       rotation outside a fixed window.  Protocols SHOULD define such
       policies.

5.4.  Cache behaviour

   Caching the Key Directory lowers latency and reduces resource usage
   on the Mirror and the Origin.  An optimal caching strategy should
   minimize resource usage for both the Client and Origin while
   preventing the client from using an invalid key.

   These two requirements, minimizing resource usage and never using an
   invalid key, are at odds with each other.  In the event of an
   unplanned key rotation, a client might use an invalid key.  However,
   if a client fetched the keys for every request, it would waste time
   and network resources.

5.4.1.  not-before fields

   Origins SHOULD, when possible in the Key Directory format, add a not-
   before field or equivalent to each Key in the Directory.  The not-
   before field allows the directory to signal to a client when a Key is
   safe to use and reduces the chance a client uses an expired key.
   When the unit of time used for the not-before field is ambiguous, it
   MUST be a Unix epoch timestamp in seconds.

5.4.2.  cache directives

   Origins SHOULD respond with cache directives[HTTP-CACHE] which
   control when the Key Directory should be refreshed.  Origins SHOULD
   provide a Cache-Control: max-age header, or Expires header which is
   slightly less than the grace period given for a key about to rotate.
   Clients SHOULD respect the max-age cache directive and MAY respect
   other directives.  If an Origin provides a max-age header AND a
   Mirror is used, the Origin MUST provide a s-maxage header that is
   equivalent to max-age.

   To prevent Clients refreshing their Key Directories at the same time
   (synchronization), Mirrors SHOULD provide to its clients a max-age
   cache directive with duration in the range [0, Origin s-maxage].

5.4.3.  Client cache refresh

   The primary method a Client SHOULD use to determine when it refreshes
   its view of the Key Directory is through the delta seconds described
   in the max-age cache directive.  The higher the delta, the less
   frequent a Client will update its cache.  The lower the delta, the
   quicker clients will respond to unplanned key rotations.

5.5.  Well known URL

   It is RECOMMENDED protocol register a [WELL-KNOWN]URL and associated
   content-type.

   A key directory server MUST support both GET and HEAD request on that
   endpoint.

  GET /.well-known/<your-protocol>

  HTTP/1.1 200 OK
  Cache-Control: max-age=<Client Cache TTL>, s-maxage=<Shared Cache TTL>
  Content-Type: <your-protocol>
  Last-Modified: <datestamp>

   HEAD requests can be used by clients to cheaply determine if the
   directory has changed.  The Origin server SHOULD issue a Last-
   Modified header with the date stamp of when the key directory
   resource was last modified.

   If issuing a Last-Modified header, the Origin server SHOULD support
   the correct response to a 'If-Modified-Since' HTTP GET or HEAD
   request, returning the appropriate HTTP status codes [HTTP-CACHE]

   It is RECOMMENDED that Mirrors support Last-Modified and 'If-
   Modified-Since' [HTTP-CACHE]

5.6.  Future considerations

   These considerations should be addressed in future drafts.

5.6.1.  Consistency

   Consistency allows client to prevent themselves from split view
   attack.  A proposal that has been made for Privacy Pass is to use
   multiple mirrors [CONSISTENCY].  With a sufficiently high quorum,
   clients get more confident that they are not singled out.  It
   presents scalability issues as you need multiple mirrors, and have
   one more requests from client per mirror in the quorum.

5.6.2.  Key Transparency

   Key Directory over HTTP should integrate with transparency, once the
   protocol has been defined in [KEYTRANS].  There are specific
   consideration as to what goes in the log: the full directory, keys
   individually, privacy considerations.

6.  Deployment Considerations

   Rotation schedule: fast?  Proxy improves client experience and
   shields key directory server

7.  Privacy Considerations

   TODO Privacy

   Clients fetching keys mean they reveal their IP, time, and other
   informations.  When the key directory is for an external service,
   Clients SHOULD consider proxying their traffic through a mirror
   server.  Mirrors SHOULD NOT collide with the key server.

8.  Security Considerations

   TODO Security

9.  IANA Considerations

   This document has no IANA actions.

10.  References

10.1.  Normative References

   [CONSISTENCY]
              "*** BROKEN REFERENCE ***".

   [COSE]     Schaad, J., "CBOR Object Signing and Encryption (COSE)",
              RFC 8152, DOI 10.17487/RFC8152, July 2017,
              <https://www.rfc-editor.org/rfc/rfc8152>.

   [DAP]      Geoghegan, T., Patton, C., Pitman, B., Rescorla, E., and
              C. A. Wood, "Distributed Aggregation Protocol for Privacy
              Preserving Measurement", Work in Progress, Internet-Draft,
              draft-ietf-ppm-dap-14, 3 February 2025,
              <https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-
              14>.

   [HTTP]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9110>.

   [HTTP-CACHE]
              Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Caching", STD 98, RFC 9111,
              DOI 10.17487/RFC9111, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9111>.

   [JOSE]     Jones, M., "JSON Web Key (JWK)", RFC 7517,
              DOI 10.17487/RFC7517, May 2015,
              <https://www.rfc-editor.org/rfc/rfc7517>.

   [KEYTRANS] McMillion, B. and F. Linker, "Key Transparency Protocol",
              Work in Progress, Internet-Draft, draft-ietf-keytrans-
              protocol-00, 10 December 2024,
              <https://datatracker.ietf.org/doc/html/draft-ietf-
              keytrans-protocol-00>.

   [OHTTP]    Thomson, M. and C. A. Wood, "Oblivious HTTP", RFC 9458,
              DOI 10.17487/RFC9458, January 2024,
              <https://www.rfc-editor.org/rfc/rfc9458>.

   [PRIVACYPASS]
              Celi, S., Davidson, A., Valdez, S., and C. A. Wood,
              "Privacy Pass Issuance Protocols", RFC 9578,
              DOI 10.17487/RFC9578, June 2024,
              <https://www.rfc-editor.org/rfc/rfc9578>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/rfc/rfc8446>.

   [WELL-KNOWN]
              Nottingham, M., "Well-Known Uniform Resource Identifiers
              (URIs)", RFC 8615, DOI 10.17487/RFC8615, May 2019,
              <https://www.rfc-editor.org/rfc/rfc8615>.

10.2.  Informative References

   [RFC9000]  Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", RFC 9000,
              DOI 10.17487/RFC9000, May 2021,
              <https://www.rfc-editor.org/rfc/rfc9000>.

Appendix A.  Test vectors

   List how to test cache List how to test rotation

Appendix B.  Use cases

   See existing key directory on https://key-directory-over-
   http.research.cloudflare.com/

B.1.  DAP

   HpkeConfigList [1]

   HpkeConfig HpkeConfigList<0..2^16-1>;

   struct {
     HpkeConfigId id;
     HpkeKemId kem_id;
     HpkeKdfId kdf_id;
     HpkeAeadId aead_id;
     HpkePublicKey public_key;
   } HpkeConfig;

   opaque HpkePublicKey<0..2^16-1>;
   uint16 HpkeAeadId; /* Defined in [HPKE] */
   uint16 HpkeKemId;  /* Defined in [HPKE] */
   uint16 HpkeKdfId;  /* Defined in [HPKE] */

   Partially informed comments:

   *  HpkeConfigId could be removed

   *  Need not-before to handle early capture

   [1] https://datatracker.ietf.org/doc/html/draft-ietf-ppm-dap-
   13#section-4.5.1

B.2.  OHTTP

   Key Configutation [1]

   HPKE Symmetric Algorithms {
     HPKE KDF ID (16),
     HPKE AEAD ID (16),
   }

   Key Config {
     Key Identifier (8),
     HPKE KEM ID (16),
     HPKE Public Key (Npk * 8),
     HPKE Symmetric Algorithms Length (16) = 4..65532,
     HPKE Symmetric Algorithms (32) ...,
   }

   Partially informed comments:

   *  Key Identifier could be removed/be deterministic

   *  No mention of not-before

   *  No mention of HTTP Caching for rotation

   [1] https://www.ietf.org/rfc/rfc9458.html#name-key-configuration

B.3.  Privacy Pass

   Issuer directory [1]

    {
       "issuer-request-uri": "https://issuer.example.net/request",
       "token-keys": [
         {
           "token-type": 2,
           "token-key": "MI...AB",
           "not-before": 1686913811,
         },
         {
           "token-type": 2,
           "token-key": "MI...AQ",
         }
       ]
    }

   Partially informed comments: * Not as flexible as HPKE * Has some
   protocol metadata (token-type, issuer-request-uri, rate-limit)

   [1] https://www.rfc-editor.org/rfc/rfc9578#name-configuration

B.4.  Masque relay

   ..

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Fisher Darling
   Cloudflare Inc.
   Email: fisher@darling.dev


   Thibault Meunier
   Cloudflare Inc.
   Email: ot-ietf@thibault.uk


   Simon Newton
   Cloudflare Inc.
   Email: rfc@simonnewton.com
